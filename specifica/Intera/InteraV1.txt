
### Struttura Semplice per l'Applicazione di Scambio di Carte Marvel

Questa struttura è progettata per essere semplice e facile da comprendere, mantenendo la separazione delle responsabilità tra i vari componenti dell'applicazione.

#### 1. Struttura delle Cartelle
- **/src**: Contiene tutto il codice sorgente dell'applicazione.
  - **/api**: Moduli dell'API, organizzati per versione (`v1`). Ogni modulo (`users`, `cards`, `trades`) include:
    - **Controller**: Gestisce le richieste HTTP e invoca i servizi.
    - **Route**: Definisce le rotte HTTP (es. `POST /users/register`, `GET /cards/:id`).
    - **Service**: Contiene la logica di business per ogni risorsa.
    - **Model**: Definisce i modelli dei dati utilizzando Mongoose.
    - **Validator** (opzionale): Gestisce la validazione degli input.
  - **/middlewares**: Contiene i middleware comuni per la gestione delle richieste.
    - **errorHandler.js**: Gestione centralizzata degli errori.
    - **auth.js**: Middleware per autenticare le richieste (opzionale).
  - **/config**: Configurazione dell'applicazione.
    - **database.js**: Configurazione e connessione al database MongoDB.
    - **env.js**: Gestione delle variabili d'ambiente (es. API keys, URL del database).
  - **/loaders**: Caricamento e configurazione delle componenti principali dell'applicazione.
    - **expressLoader.js**: Configurazione di Express, caricamento delle rotte e middleware.
    - **mongooseLoader.js**: Connessione e configurazione di Mongoose.
  - **app.js**: Configurazione e inizializzazione principale dell'applicazione.
  - **server.js**: Entry point dell'applicazione, avvio del server e ascolto delle richieste.

#### 2. Descrizione delle Componenti Principali
- **Presentation Layer (Web Layer)**: Gestisce le richieste HTTP e risponde al client.
  - Gestione delle rotte e validazione degli input.
  - Interazione con il livello di business tramite i controller.
  
- **Business Logic Layer (Service Layer)**: Contiene la logica di business principale.
  - Implementazione delle operazioni di creazione, aggiornamento, cancellazione e gestione delle risorse.

- **Data Access Layer (DAL)**: Gestisce l'accesso ai dati.
  - Definizione e gestione dei modelli di dati tramite Mongoose.
  
#### 3. Modulo Utenti
- **Gestione degli utenti**:
  - Registrazione di nuovi utenti.
  - Aggiornamento delle informazioni utente.
  - Eliminazione dell'account utente.

Questa struttura offre una base solida per la tua applicazione, mantenendo le componenti separate e modulari, facilitando la manutenzione e l'espansione futura.


### Specifica dell'Applicazione di Scambio di Carte Marvel

#### 1. Gestione degli Utenti
- **Registrazione Utente**:
  - **Endpoint**: `/api/users/register`
  - **Metodo**: `POST`
  - **Descrizione**: Permette a un nuovo utente di registrarsi nel sistema fornendo un nome utente, un'email, una password, e il supereroe preferito.
  - **Request Payload**:
    ```json
    {
      "username": "JohnDoe",
      "email": "johndoe@example.com",
      "password": "plainpassword",
      "favorite_superhero": "Spider-Man"
    }
    ```
  - **Risposta di Successo**:
    - **Status Code**: `201 Created`
    - **Body**:
    ```json
    {
      "message": "Registrazione avvenuta con successo",
      "user_id": "user_id_here"
    }
    ```
  - **Risposta di Errore**:
    - **Status Code**: `400 Bad Request`
    - **Body**:
    ```json
    {
      "message": "Errore nella registrazione",
      "error": "Dettagli dell'errore"
    }
    ```

- **Modifica Informazioni Utente**:
  - **Endpoint**: `/api/users/update`
  - **Metodo**: `PUT`
  - **Descrizione**: Permette a un utente registrato di aggiornare le proprie informazioni, ad eccezione dell'email.
  - **Request Payload**:
    ```json
    {
      "user_id": "user_id_here",
      "username": "NewUsername",
      "password": "newpassword",
      "favorite_superhero": "Iron Man"
    }
    ```
  - **Risposta di Successo**:
    - **Status Code**: `200 OK`
    - **Body**:
    ```json
    {
      "message": "Informazioni aggiornate con successo"
    }
    ```
  - **Risposta di Errore**:
    - **Status Code**: `400 Bad Request`
    - **Body**:
    ```json
    {
      "message": "Errore nell'aggiornamento delle informazioni",
      "error": "Dettagli dell'errore"
    }
    ```

- **Rimozione Utente**:
  - **Endpoint**: `/api/users/delete`
  - **Metodo**: `DELETE`
  - **Descrizione**: Permette all'utente di eliminare il proprio account inserendo una parola di controllo (ad esempio "Delete") per confermare l'azione.
  - **Request Payload**:
    ```json
    {
      "user_id": "user_id_here",
      "confirmation": "Delete"
    }
    ```
  - **Risposta di Successo**:
    - **Status Code**: `200 OK`
    - **Body**:
    ```json
    {
      "message": "Account eliminato con successo"
    }
    ```
  - **Risposta di Errore**:
    - **Status Code**: `400 Bad Request`
    - **Body**:
    ```json
    {
      "message": "Errore nell'eliminazione dell'account",
      "error": "Dettagli dell'errore"
    }
    ```

#### 2. Gestione dei Crediti
- **Incremento Crediti**:
  - **API**: `Incremento crediti`
  - **Descrizione**: Permette agli utenti di incrementare i loro crediti virtuali selezionando una quantità. Questa funzionalità è limitata a un range prestabilito (es. min 1, max 99).

- **Acquisto Pacchetto Carte**:
  - **API**: `Acquisto pacchetto carte`
  - **Descrizione**: Gli utenti possono spendere i loro crediti per acquistare pacchetti di carte. Ogni pacchetto contiene un numero predefinito di carte selezionate casualmente tra le 1564 disponibili.

#### 3. Gestione dell'Album
- **Recupero Informazioni Carte per Pagina**:
  - **API**: `Recupero informazioni carte pagina`
  - **Descrizione**: Quando un utente naviga tra le pagine dell'album, questa API recupera le informazioni delle carte presenti nella pagina selezionata.

- **Ricerca Figurine per Nome**:
  - **API**: Integrata con `Recupero informazioni carte pagina`
  - **Descrizione**: Barra di ricerca che permette agli utenti di cercare specifiche figurine per nome, filtrando i risultati visualizzati nell'album.

- **Recupero Informazioni Carta**:
  - **API**: `Recupero informazioni carta`
  - **Descrizione**: Quando un utente seleziona una figurina dall'album, questa API recupera le informazioni dettagliate della carta, inclusi i dettagli associati.

#### 4. Vendita di Figurine
- **Vendita Carta**:
  - **API**: `Vendita carta`
  - **Descrizione**: Permette agli utenti di vendere una figurina di cui possiedono più di una copia. La vendita è eseguita a un prezzo costante e incrementa i crediti dell'utente.

#### 5. Gestione delle Proposte di Scambio
- **Recupero Proposte della Community**:
  - **API**: `Recupero proposte community`
  - **Descrizione**: Recupera le proposte di scambio disponibili nella community per la visualizzazione e l'eventuale partecipazione da parte degli utenti.

- **Invio Offerta per Proposta**:
  - **API**: `Invio offerta per proposta`
  - **Descrizione**: Permette agli utenti di inviare un'offerta in risposta a una proposta di scambio presente nella community.

- **Recupero Informazioni su Offerte e Proposte dell'Utente**:
  - **API**: `Recupero informazioni: offerte a proposte utente, offerte utente, proposte utente`
  - **Descrizione**: Recupera le informazioni sulle offerte e le proposte fatte dall'utente o ricevute per le sue proposte.

- **Eliminazione Proposta Utente**:
  - **API**: `Eliminazione proposte utente`
  - **Descrizione**: Permette agli utenti di eliminare una delle loro proposte di scambio presenti nella community.

- **Eliminazione Offerta Utente**:
  - **API**: `Eliminazione offerte utente`
  - **Descrizione**: Permette agli utenti di ritirare un'offerta fatta per una proposta di scambio.

- **Inserimento Proposta nella Community**:
  - **API**: `Inserimento proposta in community`
  - **Descrizione**: Gli utenti possono inserire nuove proposte di scambio nella community specificando le carte che intendono scambiare e quelle che cercano.

- **Gestione delle Offerte alle Proposte dell'Utente**:
  - **Rifiuto Offerta**:
    - **API**: `Rifiuto offerta a proposta utente`
    - **Descrizione**: Permette all'utente di rifiutare un'offerta ricevuta per una delle sue proposte di scambio.

  - **Accettazione Offerta**:
    - **API**: `Accettazione offerta a proposta utente`
    - **Descrizione**: Permette all'utente di accettare un'offerta ricevuta, completando lo scambio e aggiornando i rispettivi album.

### Dati / Struttura Necessari al Avvio
Al momento dell'avvio dell'applicazione sul server, devono essere presenti i seguenti dati strutturati:

1. **Set Completo di Tutte le Carte**:
   - Una collezione `cards` che contiene tutti i 1564 ID delle carte Marvel. Ogni documento della collezione include:
     - **`_id`**: ID della carta.
     - **`name`**: Nome della carta.
     - **`description`**: Descrizione (opzionale).


### Struttura dei Dati per l'Applicazione di Scambio di Carte Marvel

#### 1. User (Utente)

Rappresenta un utente registrato nell'applicazione.

**Campi:**
- `_id`: Identificativo univoco dell'utente (generato automaticamente).
- `username`: Nome utente univoco.
- `email`: Indirizzo email univoco dell'utente.
- `password`: Password dell'utente, memorizzata in forma crittografata.
- `favorite_superhero`: Supereroe preferito dell'utente.
- `credits`: Crediti virtuali dell'utente, utilizzati per acquistare carte.
- `album`: Una lista contenente tutti i 1564 ID delle carte Marvel, con informazioni sulla quantità posseduta.

**Schema di `album`:**
- `card_id`: Riferimento all'ID della carta.
- `quantity`: Numero di copie della carta possedute. Se `quantity` è 0, significa che l'utente non possiede ancora quella carta.
- `available_quantity`: Numero di copie disponibili per scambio. Se `quantity` è 0, `available_quantity` deve essere anche 0.

#### 2. Card (Carta)

Rappresenta una carta individuale nell'album.

**Campi:**
- `_id`: Identificativo univoco della carta (derivato dall'API Marvel).
- `name`: Nome della carta (es. "Spider-Man").
- `description`: Descrizione della carta.
- `series_ids`: Elenco di ID delle serie a cui la carta appartiene (opzionale).
- `stories_ids`: Elenco di ID delle storie a cui la carta appartiene (opzionale).
- `events_ids`: Elenco di ID degli eventi a cui la carta appartiene (opzionale).

#### 3. Trade (Scambio)

Rappresenta una proposta di scambio tra due utenti.

**Campi:**
- `_id`: Identificativo univoco dello scambio.
- `proposer_id`: ID dell'utente che propone lo scambio.
- `receiver_id`: ID dell'utente che riceve la proposta di scambio.
- `proposed_cards`: Elenco delle carte offerte dal proponente.
- `requested_cards`: Elenco delle carte richieste al destinatario.
- `status`: Stato dello scambio (`pending`, `accepted`, `rejected`).
- `created_at`: Data di creazione della proposta di scambio.
- `updated_at`: Data di ultimo aggiornamento della proposta di scambio.

**Schema di `proposed_cards` e `requested_cards`:**
- `card_id`: Riferimento all'ID della carta.
- `quantity`: Numero di copie della carta offerte o richieste.

Your server application is designed to manage user accounts, handle album management (including paginated access and searching), and interact with external APIs (like the Marvel API) to fetch detailed information about characters. Below is a complete summary of the application, covering its structure, functionalities, and APIs.

1. Project Structure Overview
plaintext
Copia codice
src/
├── api/
│   ├── v1/
│   │   ├── users/
│   │   │   ├── controller.js          # Handles incoming requests for user operations
│   │   │   ├── route.js               # Defines routes related to user operations
│   │   │   ├── service.js             # Contains business logic for user management
│   │   │   ├── model.js               # Mongoose schema for the User model
│   │   ├── album/
│   │   │   ├── controller.js          # Handles incoming requests for album operations
│   │   │   ├── route.js               # Defines routes related to album management
│   │   │   ├── service.js             # Contains business logic for album management
│   │   ├── shared/
│   │   │   ├── utils/
│   │   │   │   ├── md5.js             # Utility function for generating MD5 hashes
├── config/
│   ├── config.js                      # Configuration file (e.g., for DB connection)
├── loaders/
│   ├── expressLoader.js               # Loads and configures Express
│   ├── mongooseLoader.js              # Connects to MongoDB
├── middlewares/
│   ├── auth.js                        # Middleware for JWT authentication
├── app.js                             # Main application file, initializing loaders
├── server.js                          # Entry point for starting the server
2. Functional Modules
A. User Management
Register User (POST /users/register):
Input: username, email, password, favorite_superhero
Output: Creates a new user with initial credits set to 10 and an album initialized with all 1,564 card IDs, each with quantity and available_quantity set to 0.
Login User (POST /users/login):
Input: email, password
Output: Returns a JWT token if the credentials are valid.
Update User (PUT /users/update):
Input: user_id, username, password, favorite_superhero
Output: Updates the specified fields for the user, only modifying the fields provided in the request.
Delete User (DELETE /users/delete):
Input: user_id
Output: Deletes the user account.
Buy Credits (POST /users/buy-credits):
Input: user_id, amount
Output: Adds the specified number of credits to the user’s account.
Buy Card Packet (POST /users/buy-packet):
Input: user_id
Output: Deducts the cost in credits and adds a packet of cards (based on a configurable packet size) to the user’s album.
B. Album Management
Get Album Page (GET /album):
Input: user_id, page_number
Output: Retrieves the cards on the specified page with quantity > 0, including detailed information fetched from the Marvel API.
Search Cards by Name (GET /album/search):
Input: user_id, name_starts_with
Output: Searches the Marvel API for characters whose names start with the given string and returns the matching cards that the user owns with quantity > 0.
3. Shared Utilities
MD5 Hashing:
The MD5 function is used to generate the necessary hash for authenticating requests to the Marvel API. This function is placed in a shared utility module and is used across multiple services.
4. Middleware
JWT Authentication:
Middleware to protect routes, ensuring only authenticated users can access certain APIs. It verifies the JWT token provided in the Authorization header of each request.
5. APIs Summary
User Management APIs:

POST /users/register: Register a new user.
POST /users/login: Authenticate a user and return a JWT.
PUT /users/update: Update user details (username, password, favorite superhero).
DELETE /users/delete: Delete a user.
POST /users/buy-credits: Buy credits for a user.
POST /users/buy-packet: Buy a packet of cards.
Album Management APIs:

GET /album: Retrieve paginated album data (15 cards per page).
GET /album/search: Search for cards by character name.
Next Steps: Client-Side Development
With this server-side structure and functionality in place, the next step is to develop the client side of your application. The client will need to:

Handle User Authentication: Implement login functionality and manage the JWT token.
Interact with the Server API: Make requests to the server for user management, album management, and display the data in the UI.
Implement UI Components:
User Registration and Login: Forms to register and log in users.
Album Pagination: UI components to navigate through the album pages.
Search Functionality: A search bar to find specific cards by character name.



Code 

SERVER

// src/app.js
import express from 'express';
import expressLoader from './loaders/expressLoader.js';
import mongooseLoader from './loaders/mongooseLoader.js';

const startServer = async () => {
  const app = express();

  // Loaders
  await mongooseLoader();
  await expressLoader({ app });

  return app;
};

export default startServer;

// src/server.js
import dotenv from 'dotenv';
import startServer from './app.js';

dotenv.config();

startServer().then(app => {
  const PORT = process.env.PORT || 3000;
  app.listen(PORT, () => {
    console.log(`Server is running on port ${PORT}`);
  });
}).catch(error => {
  console.error('Server failed to start:', error);
});

//src/middlewares/auth.js
import userService from '../api/users/service.js';

export const authenticateJWT = async (req, res, next) => {
    const token = req.headers.authorization && req.headers.authorization.split(' ')[1];
    
    if (!token) {
        return res.status(401).json({ message: 'Access denied, no token provided' });
    }

    try {
        const decoded = await userService.verifyToken(token);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ message: 'Invalid or expired token' });
    }
};

// src/middlewares/errorHandler.js

const errorHandler = (err, req, res, next) => {
    // Log the error stack for debugging (optional in production)
    console.error(err.stack);
  
    // Set the response status code; if it's not set, default to 500 (Internal Server Error)
    const statusCode = err.statusCode || 500;
  
    // Respond with the error message and status code
    res.status(statusCode).json({
      message: err.message || 'An unexpected error occurred',
      // Optionally include stack trace in development mode for debugging purposes
      ...(process.env.NODE_ENV === 'development' ? { stack: err.stack } : {})
    });
  };
  
  // Use ES6 export default syntax to export the middleware
  export default errorHandler;
  
// src/loaders/expressLoader.js

import bodyParser from 'body-parser';
import cors from 'cors';
import swaggerUi from 'swagger-ui-express';
import swaggerSpec from '../config/swagger.js';
import userRoutes from '../api/users/route.js';
import albumRoutes from '../api/album/route.js';
import errorHandler from '../middlewares/errorHandler.js';

export default async ({ app }) => {
  app.use(cors());
  app.use(bodyParser.json());

  // Swagger UI setup
  app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

  // Load API routes
  app.use('/api/users', userRoutes);

  app.use('/api/album', albumRoutes)

  // Error Handler (should be the last middleware)
  app.use(errorHandler);
};


// src/loaders/mongooseLoader.js
import mongoose from 'mongoose';
import config from '../config/database.js';

export default async () => {
  try {
    await mongoose.connect(config.mongoURI);
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    throw error;
  }
};


// src/config/database.js
export default {
    mongoURI: process.env.MONGO_URI || 'mongodb://localhost:27017/marvel_cards',
  };

//src/config/swagger.js
import swaggerJsdoc from 'swagger-jsdoc';

const options = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'Marvel Trading Card API',
      version: '1.0.0',
      description: 'API documentation for the Marvel Trading Card application',
    },
    servers: [
      {
        url: 'http://localhost:3000/api',
        description: 'Development server',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
        },
      },
      schemas: {
        User: {
          type: 'object',
          properties: {
            _id: {
              type: 'string',
            },
            username: {
              type: 'string',
            },
            email: {
              type: 'string',
            },
            favorite_superhero: {
              type: 'string',
            },
            credits: {
              type: 'integer',
            },
          },
          example: {
            _id: '60d5ec49b60e3f4d9c31a2b8',
            username: 'JohnDoe',
            email: 'johndoe@example.com',
            favorite_superhero: 'Spider-Man',
            credits: 10,
          },
        },
      },
    },
    security: [
      {
        bearerAuth: [], // Applies to all endpoints unless overridden
      },
    ],
  },
  apis: ['./src/api/**/*.js'], // Files containing Swagger annotations
};

const swaggerSpec = swaggerJsdoc(options);

export default swaggerSpec;

//src/api/album/controller.js
import albumService from './service.js';

class AlbumController {
  async getAlbumPage(req, res, next) {
    try {
      const { page_number } = req.query;
      
      // Extract userId from the decoded JWT token, not from the request query
      const userId = req.user.userId;

      const cards = await albumService.getCardsForPage(userId, page_number);
      res.status(200).json(cards);
    } catch (error) {
      next(error);
    }
  }

  async searchCards(req, res, next) {
    try {
      const { name_starts_with } = req.query;
      
      // Extract userId from the decoded JWT token
      const userId = req.user.userId;

      const cards = await albumService.searchCardsByName(userId, name_starts_with);
      res.status(200).json(cards);
    } catch (error) {
      next(error);
    }
  }
}

export default new AlbumController();

// src/api/album/route.js
import express from 'express';
import albumController from './controller.js';
import { authenticateJWT } from '../../middlewares/auth.js';

const router = express.Router();

/**
 * @swagger
 * /album/cards:
 *   get:
 *     summary: Retrieve cards for a specific album page
 *     tags: [Album]
 *     security:
 *       - bearerAuth: []  # JWT token is required
 *     parameters:
 *       - in: query
 *         name: page_number
 *         schema:
 *           type: integer
 *         required: true
 *         description: The page number of the album to retrieve cards from
 *     responses:
 *       200:
 *         description: A list of cards for the specified page
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 page:
 *                   type: integer
 *                   description: The page number
 *                 cards:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the card
 *                       name:
 *                         type: string
 *                         description: The name of the character associated with the card
 *                       quantity:
 *                         type: integer
 *                         description: The quantity of this card in the user's album
 *                       available_quantity:
 *                         type: integer
 *                         description: The available quantity of this card in the user's album
 *                       details:
 *                         type: object
 *                         description: Additional details about the character, fetched from the Marvel API
 *       400:
 *         description: Bad request
 *       404:
 *         description: User not found or no cards available on the specified page
 */
router.get('/cards', authenticateJWT, albumController.getAlbumPage);

/**
 * @swagger
 * /album/search:
 *   get:
 *     summary: Search for cards by character name
 *     tags: [Album]
 *     security:
 *       - bearerAuth: []  # JWT token is required
 *     parameters:
 *       - in: query
 *         name: name_starts_with
 *         schema:
 *           type: string
 *         required: true
 *         description: The string that the character names start with
 *     responses:
 *       200:
 *         description: A list of cards matching the search string that the user owns
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the card
 *                   name:
 *                     type: string
 *                     description: The name of the character associated with the card
 *                   quantity:
 *                     type: integer
 *                     description: The quantity of this card in the user's album
 *                   available_quantity:
 *                     type: integer
 *                     description: The available quantity of this card in the user's album
 *                   details:
 *                     type: object
 *                     description: Additional details about the character, fetched from the Marvel API
 *       400:
 *         description: Bad request
 *       404:
 *         description: User not found or no matching characters available
 */
router.get('/search', authenticateJWT, albumController.searchCards);

export default router;

// src/api/album/service.js
import { User } from '../users/model.js';
import { MD5 } from '../shared/utils/md5.js';
import dotenv from 'dotenv';
import fetch from 'node-fetch';

dotenv.config();

class AlbumService {
  async getCardsForPage(userId, pageNumber) {
    const cardsPerPage = 15;
    const startIndex = (pageNumber - 1) * cardsPerPage;
    const endIndex = startIndex + cardsPerPage;

    const user = await User.findById(userId);
    if (!user) throw new Error('User not found');

    // Get the card IDs for the specified page
    const pageCards = user.album.slice(startIndex, endIndex);

    // Filter out cards with quantity <= 0
    const availableCards = pageCards.filter(card => card.quantity >= 0);

    // Fetch details for these cards from the Marvel API
    const detailedCards = await this.getCharacterDetails(availableCards.map(card => card.card_id));

    return detailedCards;
  }

  async searchCardsByName(userId, nameStartsWith) {
    const baseUrl = process.env.CHARACTERS_URL;
    const publicApiKey = process.env.MARVELAPI_PUBLICKEY;
    const privateApiKey = process.env.MARVELAPI_PRIVATEKEY;
    
    const timestamp = Date.now();
    const hash = MD5(timestamp + privateApiKey + publicApiKey);
    const authParams = `ts=${timestamp}&apikey=${publicApiKey}&hash=${hash}`;
    
    // Fetch characters that match the name search string
    const response = await fetch(`${baseUrl}?nameStartsWith=${nameStartsWith}&${authParams}`);
    const data = await response.json();

    if (!data || !data.data || data.data.results.length === 0) {
      return []; // No characters found
    }

    const foundCharacterIds = data.data.results.map(character => character.id);

    // Filter these IDs to only include those that the user owns with quantity > 0
    const user = await User.findById(userId);
    if (!user) throw new Error('User not found');

    const availableCards = user.album.filter(card => foundCharacterIds.includes(card.card_id) && card.quantity >= 0);

    // Fetch the details for these available cards from the Marvel API
    const detailedCharacters = await this.getCharacterDetails(availableCards.map(card => card.card_id));

    return detailedCharacters;
  }

  async getCharacterDetails(characterIds) {
    const baseUrl = process.env.CHARACTERS_URL;
    const publicApiKey = process.env.MARVELAPI_PUBLICKEY;
    const privateApiKey = process.env.MARVELAPI_PRIVATEKEY;
    
    const timestamp = Date.now();
    const hash = MD5(timestamp + privateApiKey + publicApiKey);
    const authParams = `ts=${timestamp}&apikey=${publicApiKey}&hash=${hash}`;

    const detailedCharacters = [];

    for (const characterId of characterIds) {
      const response = await fetch(`${baseUrl}/${characterId}?${authParams}`);
      const data = await response.json();
      if (data && data.data && data.data.results && data.data.results.length > 0) {
        detailedCharacters.push(data.data.results[0]);
      }
    }

    return detailedCharacters;
  }

}

export default new AlbumService();


// src/api/shared/utils/md5.js

export function MD5(d) {
    var M = function(d) {
      for (var _, m = "0123456789ABCDEF", f = "", r = 0; r < d.length; r++)
        _ = d.charCodeAt(r),
        f += m.charAt(_ >>> 4 & 15) + m.charAt(15 & _);
      return f;
    };
  
    var X = function(d) {
      for (var _ = Array(d.length >> 2), m = 0; m < _.length; m++) _[m] = 0;
      for (m = 0; m < 8 * d.length; m += 8) _[m >> 5] |= (255 & d.charCodeAt(m / 8)) << m % 32;
      return _;
    };
  
    var V = function(d) {
      for (var _ = "", m = 0; m < 32 * d.length; m += 8)
        _ += String.fromCharCode(d[m >> 5] >>> m % 32 & 255);
      return _;
    };
  
    var Y = function(d, _) {
      d[_ >> 5] |= 128 << _ % 32, d[14 + (_ + 64 >>> 9 << 4)] = _;
      for (var m = 1732584193, f = -271733879, r = -1732584194, i = 271733878, n = 0; n < d.length; n += 16) {
        var h = m, t = f, g = r, e = i;
        f = md5_ii(f = md5_ii(f = md5_ii(f = md5_ii(f = md5_hh(f = md5_hh(f = md5_hh(f = md5_hh(f = md5_gg(f = md5_gg(f = md5_gg(f = md5_gg(f = md5_ff(f = md5_ff(f = md5_ff(f = md5_ff(f, r = md5_ff(r, i = md5_ff(i, m = md5_ff(m, f, r, i, d[n + 0], 7, -680876936), f, r, d[n + 1], 12, -389564586), m, f, d[n + 2], 17, 606105819), i, m, d[n + 3], 22, -1044525330), r = md5_ff(r, i = md5_ff(i, m = md5_ff(m, f, r, i, d[n + 4], 7, -176418897), f, r, d[n + 5], 12, 1200080426), m, f, d[n + 6], 17, -1473231341), i, m, d[n + 7], 22, -45705983), r = md5_ff(r, i = md5_ff(i, m = md5_ff(m, f, r, i, d[n + 8], 7, 1770035416), f, r, d[n + 9], 12, -1958414417), m, f, d[n + 10], 17, -42063), i, m, d[n + 11], 22, -1990404162), r = md5_ff(r, i = md5_ff(i, m = md5_ff(m, f, r, i, d[n + 12], 7, 1804603682), f, r, d[n + 13], 12, -40341101), m, f, d[n + 14], 17, -1502002290), i, m, d[n + 15], 22, 1236535329), r = md5_gg(r, i = md5_gg(i, m = md5_gg(m, f, r, i, d[n + 1], 5, -165796510), f, r, d[n + 6], 9, -1069501632), m, f, d[n + 11], 14, 643717713), i, m, d[n + 0], 20, -373897302), r = md5_gg(r, i = md5_gg(i, m = md5_gg(m, f, r, i, d[n + 5], 5, -701558691), f, r, d[n + 10], 9, 38016083), m, f, d[n + 15], 14, -660478335), i, m, d[n + 4], 20, -405537848), r = md5_gg(r, i = md5_gg(i, m = md5_gg(m, f, r, i, d[n + 9], 5, 568446438), f, r, d[n + 14], 9, -1019803690), m, f, d[n + 3], 14, -187363961), i, m, d[n + 8], 20, 1163531501), r = md5_gg(r, i = md5_gg(i, m = md5_gg(m, f, r, i, d[n + 13], 5, -1444681467), f, r, d[n + 2], 9, -51403784), m, f, d[n + 7], 14, 1735328473), i, m, d[n + 12], 20, -1926607734), r = md5_hh(r, i = md5_hh(i, m = md5_hh(m, f, r, i, d[n + 5], 4, -378558), f, r, d[n + 8], 11, -2022574463), m, f, d[n + 11], 16, 1839030562), i, m, d[n + 14], 23, -35309556), r = md5_hh(r, i = md5_hh(i, m = md5_hh(m, f, r, i, d[n + 1], 4, -1530992060), f, r, d[n + 4], 11, 1272893353), m, f, d[n + 7], 16, -155497632), i, m, d[n + 10], 23, -1094730640), r = md5_hh(r, i = md5_hh(i, m = md5_hh(m, f, r, i, d[n + 13], 4, 681279174), f, r, d[n + 0], 11, -358537222), m, f, d[n + 3], 16, -722521979), i, m, d[n + 6], 23, 76029189), r = md5_hh(r, i = md5_hh(i, m = md5_hh(m, f, r, i, d[n + 9], 4, -640364487), f, r, d[n + 12], 11, -421815835), m, f, d[n + 15], 16, 530742520), i, m, d[n + 2], 23, -995338651), r = md5_ii(r, i = md5_ii(i, m = md5_ii(m, f, r, i, d[n + 0], 6, -198630844), f, r, d[n + 7], 10, 1126891415), m, f, d[n + 14], 15, -1416354905), i, m, d[n + 5], 21, -57434055), r = md5_ii(r, i = md5_ii(i, m = md5_ii(m, f, r, i, d[n + 12], 6, 1700485571), f, r, d[n + 3], 10, -1894986606), m, f, d[n + 10], 15, -1051523), i, m, d[n + 1], 21, -2054922799), r = md5_ii(r, i = md5_ii(i, m = md5_ii(m, f, r, i, d[n + 8], 6, 1873313359), f, r, d[n + 15], 10, -30611744), m, f, d[n + 6], 15, -1560198380), i, m, d[n + 13], 21, 1309151649), r = md5_ii(r, i = md5_ii(i, m = md5_ii(m, f, r, i, d[n + 4], 6, -145523070), f, r, d[n + 11], 10, -1120210379), m, f, d[n + 2], 15, 718787259), i, m, d[n + 9], 21, -343485551), m = safe_add(m, h), f = safe_add(f, t), r = safe_add(r, g), i = safe_add(i, e)
      }
      return Array(m, f, r, i);
    };
  
    function md5_cmn(q, w, e, r, t, y) {
      return safe_add(bit_rol(safe_add(safe_add(w, q), safe_add(r, y)), t), e);
    }
  
    function md5_ff(q, w, e, r, t, y, u) {
      return md5_cmn(w & e | ~w & r, q, w, t, y, u);
    }
  
    function md5_gg(q, w, e, r, t, y, u) {
      return md5_cmn(w & r | e & ~r, q, w, t, y, u);
    }
  
    function md5_hh(q, w, e, r, t, y, u) {
      return md5_cmn(w ^ e ^ r, q, w, t, y, u);
    }
  
    function md5_ii(q, w, e, r, t, y, u) {
      return md5_cmn(e ^ (w | ~r), q, w, t, y, u);
    }
  
    function safe_add(x, y) {
      var l = (x & 65535) + (y & 65535);
      return (x >> 16) + (y >> 16) + (l >> 16) << 16 | l & 65535;
    }
  
    function bit_rol(num, cnt) {
      return (num << cnt) | (num >>> (32 - cnt));
    }
  
    return M(V(Y(X(d), 8 * d.length))).toLowerCase();
  }
  

//src/api/users/controller.js
import userService from './service.js';
import { User } from './model.js';

class UserController {
  login = async (req, res) => {
    console.log('Received login request for:', req.body.email);
    try {
        const { email, password } = req.body;
        const { userId, token } = await userService.loginUser(email, password);  // Destructure userId and token

        console.log('Login successful, sending response');
        // Send back both userId and token in the response
        res.status(200).json({ userId, token });
    } catch (error) {
        console.error('Error during login:', error.message);
        res.status(401).json({ message: error.message });
    }
  }

  register = async (req, res, next) => {
    try {
      const user = await userService.registerUser(req.body);
      res.status(201).json({ message: 'Registrazione avvenuta con successo', user_id: user._id });
    } catch (error) {
      next(error);
    }
  }

  getUserInfo = async (req, res) => {
    try {
        // Use req.user.userId (extracted from the token) to find the user
        const user = await User.findById(req.user.userId).select('_id username email favorite_superhero credits password');

        if (!user) {
            return res.status(404).json({ message: 'User not found' });
        }

        res.status(200).json(user);
    } catch (error) {
        console.error('Error fetching user info:', error);
        res.status(500).json({ message: 'Server error' });
    }
  }

  update = async (req, res, next) => {
    try {
      // Use userId from the JWT token
      const user = await userService.updateUser(req.user.userId, req.body);
      res.status(200).json({ message: 'Informazioni aggiornate con successo' });
    } catch (error) {
      next(error);
    }
  }

  delete = async (req, res, next) => {
    try {
      // Use userId from the JWT token
      await userService.deleteUser(req.user.userId);
      res.status(200).json({ message: 'Account eliminato con successo' });
    } catch (error) {
      next(error);
    }
  }

  buyCredits = async (req, res, next) => {
    try {
      // Use userId from the JWT token
      const { amount } = req.body;
      const credits = await userService.buyCredits(req.user.userId, amount);
      res.status(200).json({ message: 'Credits purchased successfully', credits });
    } catch (error) {
      next(error);
    }
  }

  buyCardPacket = async (req, res, next) =>{
    try {
      // Use userId from the JWT token
      const { packet_size } = req.body;
      const result = await userService.buyCardPacket(req.user.userId, packet_size);
      res.status(200).json({ message: 'Card packet purchased successfully', ...result });
    } catch (error) {
      next(error);
    }
  }
}

export default new UserController();

//src/api/users/model.js
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema({
    username: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    favorite_superhero: { type: String, required: true },
    credits: { type: Number, default: 10 },
    album: [{
        card_id: Number,
        quantity: { type: Number, default: 0 },
        available_quantity: { type: Number, default: 0 }
    }]
});

// Hash password before saving the user model
userSchema.pre('save', async function(next) {
    if (!this.isModified('password')) return next();
    this.password = await bcrypt.hash(this.password, 10);
    //development only
    console.log('\nHashed password:', this.password);  // Log hashed password
    //end development only
    next();
});

// Method to compare entered password with hashed password
userSchema.methods.comparePassword = function(password) {
    return bcrypt.compare(password, this.password);
};

export const User = mongoose.model('User', userSchema);


//src/api/users/route.js
import express from 'express';
import userController from './controller.js';
import { authenticateJWT } from '../../middlewares/auth.js';

const router = express.Router();

/**
 * @swagger
 * components:
 *   schemas:
 *     User:
 *       type: object
 *       required:
 *         - username
 *         - email
 *         - password
 *         - favorite_superhero
 *       properties:
 *         username:
 *           type: string
 *           description: Unique username of the user
 *         email:
 *           type: string
 *           description: Unique email of the user
 *         password:
 *           type: string
 *           description: User's password
 *         favorite_superhero:
 *           type: string
 *           description: The user's favorite superhero
 *         credits:
 *           type: integer
 *           description: The number of credits the user has
 *         album:
 *           type: array
 *           items:
 *             type: object
 *             properties:
 *               card_id:
 *                 type: string
 *               quantity:
 *                 type: integer
 *               available_quantity:
 *                 type: integer
 *       example:
 *         username: JohnDoe
 *         email: johndoe@example.com
 *         password: plainpassword
 *         favorite_superhero: Spider-Man
 *         credits: 0
 *         album: []
 */

/**
 * @swagger
 * /users/login:
 *   post:
 *     summary: Login a user and get a JWT token
 *     tags: [User]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               email:
 *                 type: string
 *                 description: The user's email
 *               password:
 *                 type: string
 *                 description: The user's password
 *     responses:
 *       200:
 *         description: User logged in successfully and token generated
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 token:
 *                   type: string
 *                   description: JWT token
 *                 user:
 *                   $ref: '#/components/schemas/User'
 *       401:
 *         description: Invalid credentials
 */
router.post('/login', userController.login);

/**
 * @swagger
 * /users/register:
 *   post:
 *     summary: Register a new user
 *     tags: [User]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               username:
 *                 type: string
 *               email:
 *                 type: string
 *               password:
 *                 type: string
 *               favorite_superhero:
 *                 type: string
 *     responses:
 *       201:
 *         description: User registered successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 user_id:
 *                   type: string
 *       400:
 *         description: Bad request
 */
router.post('/register', userController.register);

/**
 * @swagger
 * /users/info:
 *   get:
 *     summary: Get current user's information
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved user information
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/User'
 *       401:
 *         description: Unauthorized (invalid or missing token)
 *       404:
 *         description: User not found
 */
router.get('/info', authenticateJWT, userController.getUserInfo);

/**
 * @swagger
 * /users/update:
 *   put:
 *     summary: Update user information
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               username:
 *                 type: string
 *               password:
 *                 type: string
 *               favorite_superhero:
 *                 type: string
 *     responses:
 *       200:
 *         description: User information updated successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *       400:
 *         description: Bad request
 */
router.put('/update', authenticateJWT, userController.update);

/**
 * @swagger
 * /users/delete:
 *   delete:
 *     summary: Delete a user account
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: User deleted successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *       400:
 *         description: Bad request
 */
router.delete('/delete', authenticateJWT, userController.delete);

/**
 * @swagger
 * /users/buy-credits:
 *   post:
 *     summary: Buy credits for a user
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               amount:
 *                 type: integer
 *                 description: The number of credits to buy
 *     responses:
 *       200:
 *         description: Credits purchased successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 credits:
 *                   type: integer
 *       400:
 *         description: Bad request
 */
router.post('/buy-credits', authenticateJWT, userController.buyCredits);

/**
 * @swagger
 * /users/buy-packet:
 *   post:
 *     summary: Buy a card packet for a user
 *     tags: [User]
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               packet_size:
 *                 type: integer
 *                 description: The size of the card packet to buy
 *     responses:
 *       200:
 *         description: Card packet purchased successfully
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                 credits:
 *                   type: integer
 *                 newCards:
 *                   type: array
 *                   items:
 *                     type: integer
 *                     description: The card IDs in the purchased packet
 *       400:
 *         description: Bad request
 */
router.post('/buy-packet', authenticateJWT, userController.buyCardPacket);

export default router;



// src/api/users/service.js
import { User } from './model.js';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import jwt from 'jsonwebtoken'; 

class UserService {
  async loginUser(email, password) {
      console.log('Starting login process for email:', email);
      
      const user = await User.findOne({ email });
      if (!user) {
          console.log('User not found');
          throw new Error('Invalid credentials');
      }

      const isMatch = await user.comparePassword(password);
      console.log('Password match:', isMatch);

      if (!isMatch) {
          throw new Error('Invalid credentials');
      }

      try {
          const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: '1h' });
          console.log('Generated Token:', token);
          return { userId: user._id, token };
      } catch (error) {
          console.error('Error generating token:', error);
          throw new Error('Token generation failed');
      }
  }

  async verifyToken(token) {
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        return decoded;
    } catch (error) {
        throw new Error('Invalid or expired token');
    }
  }

  async registerUser(userData) {
    // Load card IDs from the JSON file
    const cardIds = this.loadCardIdsFromFile();

    // Populate the album array with card IDs
    const album = cardIds.map(card_id => ({
      card_id: card_id, // Numeric IDs
      quantity: 0,
      available_quantity: 0,
    }));

    // Set initial credits and album
    userData.credits = 10;
    userData.album = album;

    // Create and save the user
    const user = new User(userData);
    await user.save();
    return user;
  }

  loadCardIdsFromFile() {
    // Convert import.meta.url to __dirname equivalent
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);

    // Use path.join to create the correct file path
    const filePath = path.join(__dirname, '../../../data/marvel_character_ids.json');
    const fileContents = fs.readFileSync(filePath, 'utf-8');
    const card_ids = JSON.parse(fileContents);
    return card_ids;
  }

  async updateUser(userId, updateData) {
    // Restrict updates to only username, password, and favorite_superhero
    const fieldsToUpdate = {};
    if (updateData.username) fieldsToUpdate.username = updateData.username;
    if (updateData.password) fieldsToUpdate.password = updateData.password;
    if (updateData.favorite_superhero) fieldsToUpdate.favorite_superhero = updateData.favorite_superhero;

    const user = await User.findByIdAndUpdate(userId, fieldsToUpdate, { new: true });
    return user;
  }

  async deleteUser(userId) {
    await User.findByIdAndDelete(userId);
    return true;
  }

  async buyCredits(userId, amount) {
    const user = await User.findById(userId);
    if (!user) throw new Error('User not found');

    user.credits += amount;
    await user.save();

    return user.credits;
  }

  async buyCardPacket(userId) {
    const packetSize = parseInt(process.env.PACKET_SIZE, 10);
    const packetCost = parseInt(process.env.PACKET_COST, 10);

    const user = await User.findById(userId);
    if (!user) throw new Error('User not found');
    if (user.credits < packetCost) throw new Error('Not enough credits');

    // Deduct the packet price from the user's credits
    user.credits -= packetCost;

    // Load card IDs from the JSON file to randomly pick cards
    const cardIds = this.loadCardIdsFromFile();

    // Randomly select cards to add to the user's album
    const newCards = [];
    for (let i = 0; i < packetSize; i++) {
      const randomIndex = Math.floor(Math.random() * cardIds.length);
      const card_id = cardIds[randomIndex];
      newCards.push(card_id);

      // Update the user's album
      const albumCard = user.album.find(c => c.card_id === card_id);
      if (albumCard) {
        albumCard.quantity += 1;
        albumCard.available_quantity += 1;
      } else {
        user.album.push({
          card_id: card_id,
          quantity: 1,
          available_quantity: 1,
        });
      }
    }

    await user.save();

    return {
      credits: user.credits,
      newCards: newCards,
    };
  }

}

export default new UserService();


